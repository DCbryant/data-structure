假设我们有一个没有任何排列顺序的电话通讯录。当需要添加联络人和电话时，你只能将其写在下一个空位上。假定你的联系人列表上有很多人，某天，你要找某个联系人及其电话号码。但是由于联系人列表没有按照任何顺序来组织，你只能逐个检查，直到找到那个你想要的联系人为止。这个方法低效，我们需要在列表上搜寻一个联系人，但是那通讯录列表没有进行任何组织，那得花多久时间啊？

因此（还有其他原因），我们需要组织信息集，比如那些存储在数据结构里的信息。排序和搜索算法广泛地运用在待解决的日常问题中。

## 冒泡排序

人们开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。

冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。

冒泡排序算法的复杂度是 O(n²)，并不推荐此算法

![bubbleSort](https://user-gold-cdn.xitu.io/2017/6/26/baca5f1861b9534eb85c2a2f7340a18f?imageView2/0/w/128
0/h/960/format/webp/ignore-error/1)

## 选择排序

选择排序算法是一种原址比较排序算法。选择排序算法的思路是：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推

![选择排序](https://user-gold-cdn.xitu.io/2017/6/26/fd1cf9bccf6b4147b5442f4d36fc0d59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 插入排序

插人排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着， 它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插人到第一、第二还是第三的位置呢？），以此类推。

排序小型数组时，此算法比选择排序和冒泡排序性能要好。

![插入排序](https://user-gold-cdn.xitu.io/2017/6/26/240c41b9aed4a6ef01abd1e225e11610?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 归并排序

归并排序是第一个可以被实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为O(n log^n)。

JavaScript的Array类定义了一个sort函数Array.prototype.sort用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序的变体。

归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

![归并排序](https://user-gold-cdn.xitu.io/2017/6/26/6e75ddc8f4974aecf1619c24a9a5ce5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。

## 快速排序

快速排序也许是最常用的排序算法了。它的复杂度为O(nlog^n)，且它的性能通常比其他的复杂度为O(nlog^n)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组(但它没有像归并排序那样将它们分割开)。

快速排序的基本过程：

1. 首先，从数组中选择中间一项作为主元

2. 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指 针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交 换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。

3. 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的 子数组）重复之前的两个步骤，直至数组已完全排序。

